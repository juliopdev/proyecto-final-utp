Patrones por Archivo:

SecurityConfig.java:
Singleton: Beans únicos para toda la aplicación
Factory: DaoAuthenticationProvider factory
Strategy: Diferentes estrategias de autenticación
Template Method: SecurityFilterChain template

CustomUserDetailsService.java:
Adapter: User entity → UserDetails
Proxy: Proxy entre Spring Security y repositorio
Template Method: Implementación de UserDetailsService

JwtConfig.java:
Singleton: Component único para JWT
Strategy: Diferentes estrategias de validación
Template Method: Templates para extraer claims
Factory: Factory methods para tokens

JwtRequestFilter.java:
Proxy: Proxy entre request y autenticación
Template Method: Extensión de OncePerRequestFilter
Strategy: Diferentes estrategias según endpoint
Command: Comandos de autenticación

JwtAuthenticationEntryPoint.java:
Strategy: API vs SSR responses
Template Method: AuthenticationEntryPoint
Adapter: Errores → respuestas HTTP

###################################################################################

Patrones de Diseño Implementados:
1. Patrones Creacionales:
SINGLETON: Beans de configuración únicos (SecurityConfig, JwtConfig)
FACTORY: Factory methods para crear tokens JWT, logs, y respuestas de autenticación
BUILDER: Usando Lombok en todas las entidades y DTOs

2. Patrones Estructurales:
ADAPTER:
- CustomUserDetailsService adapta User entity a UserDetails
- JwtAuthenticationEntryPoint adapta errores a respuestas HTTP
PROXY:
- Spring Data JPA/MongoDB actúan como proxies
- JwtRequestFilter como proxy de autenticación

3. Patrones Comportamentales:
STRATEGY: Diferentes estrategias de autenticación (JWT vs Session, API vs SSR)
TEMPLATE METHOD:
- SecurityFilterChain, OncePerRequestFilter
- Métodos template en controladores
OBSERVER: LogService registra eventos del sistema
COMMAND: Métodos de repositorio encapsulan comandos de BD
REPOSITORY: Abstracción completa de acceso a datos

4. Patrones de Arquitectura:
MVC: Estructura clara de controladores web
ENTITY/DOCUMENT: Mapeo objeto-relacional y NoSQL
DTO: Transferencia segura de datos
SPECIFICATION: Query methods específicos

###################################################################################

Patrones de Diseño en la Capa de Servicios:

1. Patrones Arquitecturales:
FACADE: AuthService y UserService actúan como fachadas que coordinan múltiples repositorios y servicios
STRATEGY: Diferentes estrategias de autenticación, validación y procesamiento
COMMAND: Cada método de servicio encapsula un comando específico
TEMPLATE METHOD: Templates para procesos estándar (registro, login, etc.)

2. Patrones de Comportamiento:
OBSERVER: LogService implementa el patrón Observer para registrar eventos del sistema
FACTORY: Factory methods para crear usuarios, logs, emails y respuestas
MEMENTO: LogService almacena estados históricos para auditoría

3. Patrones de Integración:
ASYNC: Logging asíncrono para no bloquear operaciones críticas
PROXY: Services actúan como proxies entre controladores y repositorios
ADAPTER: Adaptación entre entidades de PostgreSQL y documentos de MongoDB